## 요구사항 정리 

주어진 요구사항은 포인트 관리 시스템에서 사용자 포인트의 충전, 사용, 조회, 거래 내역 조회를 구현하는 것입니다. 각 기능은 **동시성 제어**를 필요로 하며, 시스템은 다음과 같은 동작을 수행해야 합니다:

1. **포인트 충전 (PATCH /point/{id}/charge)**
    - 사용자는 포인트를 충전할 수 있어야 한다.

2. **포인트 사용 (PATCH /point/{id}/use)**
    - 사용자는 포인트를 사용할 수 있어야 한다.
    - 잔고가 부족하면 포인트 사용에 실패해야 한다.

3. **포인트 잔액 조회 (GET /point/{id})**
    - 사용자는 자신의 현재 포인트 잔액을 조회할 수 있어야 한다.

4. **포인트 거래 내역 조회 (GET /point/{id}/histories)**
    - 사용자는 자신의 포인트 충전/사용 내역을 조회할 수 있어야 한다.

5. **동시성 제어**
    - 여러 사용자가 동시에 포인트를 충전하거나 사용할 때, 순차적으로 처리되어야 한다.

---

## 3-Tier 아키텍처 기반 컴포넌트 레이아웃 및 구현 순서

3-Tier 아키텍처는 **Presentation Layer (API/Controller)**, **Business Logic Layer (Service)**, **Data Access Layer (Repository)**로 구성되며, 각각의 요구사항을 어떻게 컴포넌트에 맞추어 구현할지 순서도를 작성했습니다.

#### 1. **포인트 충전 (PATCH /point/{id}/charge)**
- **Controller** (`PointController`):  
  `PATCH` 요청을 수신하고, 충전할 금액을 담은 DTO (`ChargeRequest`)를 서비스로 전달.
- **Service** (`PointService`):  
  충전 금액을 비즈니스 로직에서 처리하고, 사용자 포인트를 업데이트하며 충전 내역을 기록.
- **Repository** (`UserPointRepository`, `PointHistoryRepository`):  
  포인트 데이터를 업데이트하고 충전 내역을 기록.

#### 2. **포인트 사용 (PATCH /point/{id}/use)**
- **Controller** (`PointController`):  
  `PATCH` 요청을 수신하고, 사용할 금액을 담은 DTO (`UseRequest`)를 서비스로 전달.
- **Service** (`PointService`):  
  비즈니스 로직에서 포인트 사용을 처리하며, 잔액이 부족하면 예외 처리. 사용 내역을 기록.
- **Repository** (`UserPointRepository`, `PointHistoryRepository`):  
  포인트 데이터를 업데이트하고, 포인트 사용 내역을 기록.

#### 3. **포인트 잔액 조회 (GET /point/{id})**
- **Controller** (`PointController`):  
  `GET` 요청을 수신하고, 사용자 ID로 현재 잔액을 조회.
- **Service** (`PointService`):  
  사용자 포인트 정보를 조회하여 반환.
- **Repository** (`UserPointRepository`):  
  사용자 포인트 데이터를 조회.

#### 4. **포인트 거래 내역 조회 (GET /point/{id}/histories)**
- **Controller** (`PointController`):  
  `GET` 요청을 수신하고, 사용자 ID로 거래 내역을 조회.
- **Service** (`PointService`):  
  해당 사용자의 포인트 거래 내역을 조회하여 반환.
- **Repository** (`PointHistoryRepository`):  
  사용자 포인트 거래 내역 데이터를 조회.

#### 5. **동시성 제어**
- **Service** (`PointService`):  
  포인트 충전 및 사용 로직에 `ReentrantLock` 등 동시성 제어 메커니즘을 추가하여 여러 요청이 동시에 들어와도 순차적으로 처리.

---

## **포인트 관리 시스템 테스트 시나리오**

## 1. 서비스 레이어 테스트 (PointServiceTest)

## 1.1. 포인트 충전 테스트

### 1) 정상적인 포인트 충전
- **상황**: 사용자가 포인트를 정상적으로 충전하는 경우
- **입력**: 사용자 ID와 충전 금액이 유효함
- **예상 결과**: 잔액이 충전 금액만큼 증가해야 함

### 2) 최대 포인트 한도 초과 충전
- **상황**: 사용자가 최대 포인트 한도를 초과하여 충전하는 경우
- **입력**: 충전 금액 + 기존 잔액이 최대 포인트 한도를 초과함
- **예상 결과**: `MaxPointLimitExceededException` 발생

### 3) 충전 금액이 0일 경우
- **상황**: 사용자가 충전 금액으로 0을 입력한 경우
- **입력**: 충전 금액이 0
- **예상 결과**: `InvalidAmountException` 발생, "유효하지 않은 금액" 메시지 반환

### 4) 충전 금액이 음수일 경우
- **상황**: 사용자가 음수 금액을 충전하려는 경우
- **입력**: 충전 금액이 음수
- **예상 결과**: `InvalidAmountException` 발생, "유효하지 않은 금액" 메시지 반환

### 5) 존재하지 않는 사용자에게 충전 요청
- **상황**: 존재하지 않는 사용자 ID로 충전 요청
- **입력**: 잘못된 사용자 ID
- **예상 결과**: `UserNotFoundException` 발생, "잘못된 사용자 ID" 메시지 반환

---

## 1.2. 포인트 사용 테스트

### 1) 정상적인 포인트 사용
- **상황**: 사용자가 잔액 범위 내에서 포인트를 사용하는 경우
- **입력**: 사용자 ID와 사용 금액이 유효함
- **예상 결과**: 사용 금액만큼 잔액이 감소해야 함

### 2) 잔액이 부족한 경우
- **상황**: 사용자가 잔액보다 더 많은 포인트를 사용하려는 경우
- **입력**: 사용 금액이 잔액을 초과함
- **예상 결과**: `InsufficientBalanceException` 발생, "잔액이 부족합니다" 메시지 반환

### 3) 사용 금액이 0일 경우
- **상황**: 사용자가 0 포인트를 사용하려는 경우
- **입력**: 사용 금액이 0
- **예상 결과**: `InvalidAmountException` 발생, "유효하지 않은 금액" 메시지 반환

### 4) 사용 금액이 음수일 경우
- **상황**: 사용자가 음수 금액을 사용하려는 경우
- **입력**: 사용 금액이 음수
- **예상 결과**: `InvalidAmountException` 발생, "유효하지 않은 금액" 메시지 반환

### 5) 존재하지 않는 사용자에게 사용 요청
- **상황**: 존재하지 않는 사용자 ID로 사용 요청
- **입력**: 잘못된 사용자 ID
- **예상 결과**: `UserNotFoundException` 발생, "잘못된 사용자 ID" 메시지 반환

---

## 1.3. 포인트 잔액 조회 테스트

### 1) 정상적인 잔액 조회
- **상황**: 사용자가 자신의 잔액을 정상적으로 조회하는 경우
- **입력**: 유효한 사용자 ID
- **예상 결과**: 사용자 포인트 잔액이 정상적으로 반환됨

### 2) 잔액 조회 시 존재하지 않는 사용자
- **상황**: 존재하지 않는 사용자 ID로 잔액을 조회하려는 경우
- **입력**: 잘못된 사용자 ID
- **예상 결과**: `UserNotFoundException` 발생, "잘못된 사용자 ID" 메시지 반환

---

## 1.4. 포인트 거래 내역 조회 테스트

### 1) 정상적인 거래 내역 조회
- **상황**: 사용자가 자신의 포인트 거래 내역을 조회하는 경우
- **입력**: 유효한 사용자 ID
- **예상 결과**: 충전 및 사용 내역이 정확하게 반환됨

### 2) 거래 내역이 없는 경우
- **상황**: 사용자의 거래 내역이 없는 경우
- **입력**: 유효한 사용자 ID
- **예상 결과**: 빈 리스트가 반환됨

### 3) 존재하지 않는 사용자의 거래 내역 조회
- **상황**: 존재하지 않는 사용자 ID로 거래 내역을 조회하려는 경우
- **입력**: 잘못된 사용자 ID
- **예상 결과**: `UserNotFoundException` 발생, "잘못된 사용자 ID" 메시지 반환

---

## 2. 컨트롤러 테스트 (PointControllerTest)

### 2.1. 포인트 충전 API 테스트

#### 1) 정상적인 포인트 충전 요청
- **상황**: 사용자가 포인트를 정상적으로 충전하는 요청을 보낼 때
- **입력**: 유효한 사용자 ID 및 금액
- **예상 결과**: `200 OK` 응답

#### 2) 존재하지 않는 사용자 ID로 충전 요청
- **상황**: 존재하지 않는 사용자 ID로 충전 요청
- **입력**: 잘못된 사용자 ID
- **예상 결과**: `404 Not Found` 응답

#### 3) 잘못된 금액으로 충전 요청
- **상황**: 충전 금액이 0이거나 음수일 경우
- **입력**: 잘못된 금액
- **예상 결과**: `400 Bad Request` 응답

---

### 2.2. 포인트 사용 API 테스트

#### 1) 정상적인 포인트 사용 요청
- **상황**: 사용자가 잔액 범위 내에서 포인트 사용 요청
- **입력**: 유효한 사용자 ID 및 금액
- **예상 결과**: `200 OK` 응답

#### 2) 잔액 부족 시 포인트 사용 요청
- **상황**: 사용자가 잔액보다 더 많은 포인트를 사용하려는 요청
- **입력**: 사용 금액이 잔액보다 큼
- **예상 결과**: `400 Bad Request` 응답

#### 3) 잘못된 금액으로 포인트 사용 요청
- **상황**: 사용 금액이 0이거나 음수일 경우
- **입력**: 잘못된 금액
- **예상 결과**: `400 Bad Request` 응답

---

### 2.3. 포인트 잔액 조회 API 테스트

#### 1) 정상적인 잔액 조회 요청
- **상황**: 사용자가 자신의 잔액을 조회하는 요청
- **입력**: 유효한 사용자 ID
- **예상 결과**: `200 OK` 응답 및 잔액 반환

#### 2) 존재하지 않는 사용자 ID로 잔액 조회 요청
- **상황**: 존재하지 않는 사용자 ID로 잔액 조회 요청
- **입력**: 잘못된 사용자 ID
- **예상 결과**: `404 Not Found` 응답

---

### 2.4. 포인트 거래 내역 조회 API 테스트

#### 1) 정상적인 거래 내역 조회 요청
- **상황**: 사용자가 자신의 거래 내역을 조회하는 요청
- **입력**: 유효한 사용자 ID
- **예상 결과**: `200 OK` 응답

#### 2) 거래 내역이 없는 경우
- **상황**: 사용자의 거래 내역이 없을 때
- **입력**: 유효한 사용자 ID
- **예상 결과**: 빈 리스트 반환

#### 3) 존재하지 않는 사용자 ID로 거래 내역 조회
- **상황**: 존재하지 않는 사용자 ID로 거래 내역 조회 요청
- **입력**: 잘못된 사용자 ID
- **예상 결과**: `404 Not Found` 응답

---

## 3. 동시성 테스트 (PointServiceConcurrencyTest)

### 3.1. 동시 포인트 충전 테스트

#### 1) 동시 포인트 충전 요청
- **상황**: 여러 스레드가 동시에 동일한 사용자에 대해 포인트 충전 요청을 보낼 때
- **입력**: 여러 스레드에서 동일한 사용자 ID와 충전 금액
- **예상 결과**: 충전 금액이 정확하게 반영되고, 동시성 문제가 발생하지 않음

---

### 3.2. 동시 포인트 사용 테스트

#### 1) 동시 포인트 사용 요청
- **상황**: 여러 스레드가 동시에 동일한 사용자에 대해 포인트 사용 요청을 보낼 때
- **입력**: 여러 스레드에서 동일한 사용자 ID와 사용 금액
- **예상 결과**: 사용 금액이 정확하게 반영되고, 동시성 문제가 발생하지 않음

---

### 3.3. 동시 포인트 충전

및 사용 테스트

#### 1) 동시 포인트 충전 및 사용 요청
- **상황**: 여러 스레드가 동시에 동일한 사용자에 대해 충전과 사용 요청을 보낼 때
- **입력**: 여러 스레드에서 동일한 사용자 ID에 대해 충전과 사용 요청이 동시에 발생
- **예상 결과**: 충전과 사용 금액이 정확하게 반영되고, 동시성 문제가 발생하지 않음
---

# 포인트 서비스 동시성 제어 방식 분석

## 개요

이 문서는 포인트 관리 시스템에서 **동시성 제어**를 구현한 방식을 분석하고 설명합니다. 주요 기능은 사용자 포인트의 **충전**, **사용**, **잔액 조회**, **거래 내역 조회**이며, 특히 **동시성 제어**를 위해 어떤 기법을 사용했는지에 초점을 맞춥니다.

---

## 동시성 제어의 필요성

포인트 관리 시스템에서는 다수의 사용자가 동시에 포인트를 충전하거나 사용할 수 있습니다. 이때 **데이터 불일치**나 **레이스 컨디션**이 발생하지 않도록 동시성 제어가 필수적입니다. 예를 들어, 동일한 사용자가 동시에 포인트를 사용하면 잔액이 음수가 되거나, 예상치 못한 결과를 초래할 수 있습니다.

---

## 동시성 제어 방식

### 1. 사용자별 `ReentrantLock` 사용

- **`ConcurrentHashMap<Long, ReentrantLock> userLocks`**:
    - 각 사용자 ID(`userId`)에 대해 개별적인 `ReentrantLock`을 관리하기 위해 `ConcurrentHashMap`을 사용합니다.
    - 키로 사용자 ID를, 값으로 해당 사용자의 락을 저장합니다.
    - 이를 통해 **사용자별로 락을 관리**하여, 특정 사용자에 대한 동시 요청을 순차적으로 처리할 수 있습니다.

### 2. `executeWithLock` 메서드를 통한 락 관리

- **`private <T> T executeWithLock(Long userId, LockedOperation<T> operation)`**:
    - 공통된 락 획득 및 해제 로직을 캡슐화한 메서드입니다.
    - **람다 표현식**이나 **메서드 참조**를 사용하여 수행할 작업(`operation`)을 전달받습니다.
    - **동작 과정**:
        1. **락 획득**:
            - `userLocks.computeIfAbsent(userId, id -> new ReentrantLock())`를 통해 해당 사용자의 락을 가져오거나 생성합니다.
            - `lock.tryLock(10, TimeUnit.SECONDS)`를 통해 최대 10초까지 락 획득을 시도합니다.
            - 락 획득에 성공하면 다음 단계로 진행하고, 실패하면 예외를 발생시킵니다.
        2. **작업 수행**:
            - 전달받은 `operation.execute()`를 호출하여 실제 작업을 수행합니다.
        3. **락 해제 및 정리**:
            - 작업 완료 후 항상 `finally` 블록에서 락을 해제합니다.
            - 필요 없는 락은 `userLocks`에서 제거하여 메모리 누수를 방지합니다.

### 3. 포인트 충전 및 사용 시 동시성 제어 적용

- **포인트 충전 (`chargeUserPoint` 메서드)**:
    - `executeWithLock` 메서드를 사용하여 동시성 제어를 적용합니다.
    - 락을 획득한 후 포인트 충전 로직을 안전하게 수행합니다.
- **포인트 사용 (`usePoints` 메서드)**:
    - 마찬가지로 `executeWithLock` 메서드를 사용합니다.
    - 락을 획득한 후 포인트 사용 및 잔액 검증 로직을 수행합니다.

---

## 코드 상세 분석

### 1. `ConcurrentHashMap`과 `ReentrantLock`의 조합

- `ConcurrentHashMap`은 스레드 안전한 해시 맵으로, 동시 접근 시에도 안전하게 키-값 쌍을 관리할 수 있습니다.
- `computeIfAbsent` 메서드를 사용하여 **존재하지 않는 사용자 ID에 대해 새로운 락을 생성**하고, 이미 존재하는 경우 해당 락을 반환합니다.
- 이렇게 함으로써 **각 사용자마다 별도의 락을 유지**할 수 있습니다.

### 2. 락의 획득과 해제

- **락 획득**:
    - `tryLock` 메서드를 사용하여 락을 획득합니다.
    - 타임아웃을 설정하여 **무한 대기를 방지**하고, 일정 시간 내에 락을 획득하지 못하면 예외를 발생시킵니다.
- **락 해제**:
    - 작업이 완료되거나 예외가 발생하더라도 `finally` 블록에서 락을 해제합니다.
    - 락 해제 후 **해당 락이 더 이상 필요 없으면 `userLocks`에서 제거**하여 메모리를 관리합니다.

### 3. `executeWithLock` 메서드의 장점

- **코드 중복 제거**:
    - 락 관리 로직을 한 곳에 모아두어 코드 중복을 제거하고, 유지보수를 용이하게 합니다.
- **예외 처리 일관성**:
    - 락 획득 실패나 작업 수행 중 발생하는 예외를 일관되게 처리할 수 있습니다.
- **가독성 향상**:
    - 실제 비즈니스 로직에서는 락 관리에 대한 코드가 드러나지 않으므로 가독성이 향상됩니다.

---

## 동시성 테스트를 통한 검증

### 1. 동시 포인트 충전 테스트

- **여러 스레드가 동시에 동일한 사용자에 대해 포인트 충전 요청을 보냅니다.**
- **예상 결과**:
    - 모든 충전 금액이 정확하게 누적되어 최종 잔액이 예상한 값과 일치해야 합니다.
- **테스트 코드**:
    - `ExecutorService`를 사용하여 다수의 스레드를 생성하고, 동시에 `chargeUserPoint` 메서드를 호출합니다.
    - 테스트 완료 후 최종 잔액을 확인하여 검증합니다.

### 2. 동시 포인트 사용 테스트

- **여러 스레드가 동시에 동일한 사용자에 대해 포인트 사용 요청을 보냅니다.**
- **예상 결과**:
    - 각 사용 금액이 정확하게 차감되어 잔액이 음수가 되지 않고, 예상한 값과 일치해야 합니다.
- **테스트 코드**:
    - 마찬가지로 `ExecutorService`를 사용하여 동시에 `usePoints` 메서드를 호출합니다.
    - 최종 잔액을 확인하여 검증합니다.

### 3. 동시 포인트 충전 및 사용 테스트

- **여러 스레드가 동시에 충전과 사용 요청을 보냅니다.**
- **예상 결과**:
    - 충전과 사용이 올바르게 처리되어 최종 잔액이 예상한 값과 일치해야 합니다.
- **테스트 코드**:
    - 충전과 사용 요청을 섞어서 스레드로 실행하고, 최종 잔액을 확인합니다.

---

## 고려 사항 및 잠재적 문제점

### 1. 락 경합과 성능 저하

- **동일한 사용자에 대한 요청이 많을 경우** 락 경합이 발생하여 성능 저하가 있을 수 있습니다.
- 하지만 사용자별로 락을 관리하므로, **다른 사용자 간의 요청에는 영향이 없습니다**.

### 2. 락의 누수 방지

- 락을 사용한 후에는 반드시 해제해야 합니다.
- `finally` 블록에서 락을 해제하고, 필요 없는 락은 `userLocks`에서 제거하여 **메모리 누수를 방지**합니다.

### 3. 타임아웃 설정

- `tryLock` 메서드에서 타임아웃을 설정하여 **무한 대기를 방지**합니다.
- 타임아웃 초과 시 적절한 예외 처리를 통해 시스템의 안정성을 유지합니다.

---